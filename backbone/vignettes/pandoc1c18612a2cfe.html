<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title>backbone_introduction</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">backbone_introduction</h1>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(backbone)</a></code></pre></div>
<div id="weighted-graphs-and-backbones" class="section level1">
<h1>Weighted Graphs and Backbones</h1>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>In a graph <span class="math inline">\(G\)</span>, edges are either present (i.e. <span class="math inline">\(G_{ij}=1\)</span>) or absent (i.e. <span class="math inline">\(G_{ij}=0\)</span>). However in a weighted or valued graph, edges can take a range of values that may capture such properties as the strength or capacity of the edge. Although weighted graphs contain a large amount of information, there are some cases (e.g. visualization, application of statistical models not developed for weighted graphs) where it is useful to reduce this information by focusing on an unweighted subgraph that contains only the most important edges. We call this subgraph the backbone of <span class="math inline">\(G\)</span>, which we denote as <span class="math inline">\(G’\)</span>. Extracting <span class="math inline">\(G’\)</span> from <span class="math inline">\(G\)</span> requires deciding which edges to preserve. This usually involves selecting a threshold <span class="math inline">\(T_{ij}\)</span> such that edges are preserved if they are above the threshold (i.e. <span class="math inline">\(G’=1\)</span> if <span class="math inline">\(G_{ij} &gt; T_{ij}\)</span>), and omitted if they are below the threshold (i.e. <span class="math inline">\(G’=0\)</span> if <span class="math inline">\(G_{ij} &lt; T_{ij}\)</span>). It is also possible to extract a signed backbone by selecting upper <span class="math inline">\(T_{ij}\)</span> and lower <span class="math inline">\(T’_{ij}\)</span> thresholds such that <span class="math inline">\(G’=1\)</span> if <span class="math inline">\(G_{ij} &gt; T_{ij}\)</span>, <span class="math inline">\(G’=-1\)</span> if <span class="math inline">\(G_{ij} &lt; T’_{ij}\)</span>, and <span class="math inline">\(G’=0\)</span> if <span class="math inline">\(G_{ij} &gt; T’_{ij}\)</span> and <span class="math inline">\(G_{ij} &lt; T_{ij}\)</span>. The key to all backbone extraction methods lies in the selection of <span class="math inline">\(T\)</span>. The backbone package provides several different methods for selecting <span class="math inline">\(T\)</span> and thus extracting <span class="math inline">\(G’\)</span> from <span class="math inline">\(G\)</span>.</p>
</div>
<div id="example-data" class="section level2">
<h2>Example data</h2>
<p>We outline the use of the backbone package with Davis, Gardner, and Gardner’s Southern Women Dataset <span class="citation">(Davis, Gardner, and Gardner <a href="#ref-davis1941deep">1941</a>)</span>, which can be accessed via <span class="citation">(Repository, <a href="#ref-ucinet">n.d.</a>)</span>. This data takes the form of a bipartite graph <span class="math inline">\(B\)</span> containing 18 women (rows) and 14 social events (columns) taking place over a nine month period. In <span class="math inline">\(B\)</span>, <span class="math inline">\(B_{ij} = 1\)</span> if women <span class="math inline">\(i\)</span> attended event <span class="math inline">\(j\)</span>, and otherwise is 0. Let’s take a look at the Davis dataset included in this package to see that it is bipartite.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span>(davis) <span class="co">#load the dataset</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">davis <span class="co">#view the dataset</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">#&gt;           6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co">#&gt; EVELYN       1   1    1    1    1    1    0    1   1    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co">#&gt; LAURA        1   1    1    0    1    1    1    1   0    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co">#&gt; THERESA      0   1    1    1    1    1    1    1   1    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co">#&gt; BRENDA       1   0    1    1    1    1    1    1   0    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co">#&gt; CHARLOTTE    0   0    1    1    1    0    1    0   0    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="co">#&gt; FRANCES      0   0    1    0    1    1    0    1   0    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="co">#&gt; ELEANOR      0   0    0    0    1    1    1    1   0    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="co">#&gt; PEARL        0   0    0    0    0    1    0    1   1    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="co">#&gt; RUTH         0   0    0    0    1    0    1    1   1    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="co">#&gt; VERNE        0   0    0    0    0    0    1    1   1    0    0   1     0</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="co">#&gt; MYRNA        0   0    0    0    0    0    0    1   1    1    0   1     0</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="co">#&gt; KATHERINE    0   0    0    0    0    0    0    1   1    1    0   1     1</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16"><span class="co">#&gt; SYLVIA       0   0    0    0    0    0    1    1   1    1    0   1     1</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17"><span class="co">#&gt; NORA         0   0    0    0    0    1    1    0   1    1    1   1     1</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18"><span class="co">#&gt; HELEN        0   0    0    0    0    0    1    1   0    1    1   1     0</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19"><span class="co">#&gt; DOROTHY      0   0    0    0    0    0    0    1   1    0    0   0     0</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20"><span class="co">#&gt; OLIVIA       0   0    0    0    0    0    0    0   1    0    1   0     0</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21"><span class="co">#&gt; FLORA        0   0    0    0    0    0    0    0   1    0    1   0     0</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22"><span class="co">#&gt;           8/3</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23"><span class="co">#&gt; EVELYN      0</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24"><span class="co">#&gt; LAURA       0</span></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"><span class="co">#&gt; THERESA     0</span></a>
<a class="sourceLine" id="cb2-26" data-line-number="26"><span class="co">#&gt; BRENDA      0</span></a>
<a class="sourceLine" id="cb2-27" data-line-number="27"><span class="co">#&gt; CHARLOTTE   0</span></a>
<a class="sourceLine" id="cb2-28" data-line-number="28"><span class="co">#&gt; FRANCES     0</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29"><span class="co">#&gt; ELEANOR     0</span></a>
<a class="sourceLine" id="cb2-30" data-line-number="30"><span class="co">#&gt; PEARL       0</span></a>
<a class="sourceLine" id="cb2-31" data-line-number="31"><span class="co">#&gt; RUTH        0</span></a>
<a class="sourceLine" id="cb2-32" data-line-number="32"><span class="co">#&gt; VERNE       0</span></a>
<a class="sourceLine" id="cb2-33" data-line-number="33"><span class="co">#&gt; MYRNA       0</span></a>
<a class="sourceLine" id="cb2-34" data-line-number="34"><span class="co">#&gt; KATHERINE   1</span></a>
<a class="sourceLine" id="cb2-35" data-line-number="35"><span class="co">#&gt; SYLVIA      1</span></a>
<a class="sourceLine" id="cb2-36" data-line-number="36"><span class="co">#&gt; NORA        1</span></a>
<a class="sourceLine" id="cb2-37" data-line-number="37"><span class="co">#&gt; HELEN       0</span></a>
<a class="sourceLine" id="cb2-38" data-line-number="38"><span class="co">#&gt; DOROTHY     0</span></a>
<a class="sourceLine" id="cb2-39" data-line-number="39"><span class="co">#&gt; OLIVIA      0</span></a>
<a class="sourceLine" id="cb2-40" data-line-number="40"><span class="co">#&gt; FLORA       0</span></a></code></pre></div>
<p>We see that our two sets of vertices are women and events attended.</p>
<p>A weighted graph <span class="math inline">\(G\)</span> can be constructed from <span class="math inline">\(B\)</span> via bipartite projection, where <span class="math inline">\(G = BB’\)</span> and <span class="math inline">\(G_{ij}\)</span> contains the number of events that both woman <span class="math inline">\(i\)</span> and woman <span class="math inline">\(j\)</span> attended. Let’s first look at the weighted projection of <span class="math inline">\(G\)</span>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">davis<span class="op">%*%</span><span class="kw">t</span>(davis) <span class="co">#The projected davis dataset</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">#&gt;           EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">#&gt; EVELYN         8     6       7      6         3       4       3     3    3</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">#&gt; LAURA          6     7       6      6         3       4       4     2    3</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">#&gt; THERESA        7     6       8      6         4       4       4     3    4</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co">#&gt; BRENDA         6     6       6      7         4       4       4     2    3</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="co">#&gt; CHARLOTTE      3     3       4      4         4       2       2     0    2</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="co">#&gt; FRANCES        4     4       4      4         2       4       3     2    2</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="co">#&gt; ELEANOR        3     4       4      4         2       3       4     2    3</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="co">#&gt; PEARL          3     2       3      2         0       2       2     3    2</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="co">#&gt; RUTH           3     3       4      3         2       2       3     2    4</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="co">#&gt; VERNE          2     2       3      2         1       1       2     2    3</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"><span class="co">#&gt; MYRNA          2     1       2      1         0       1       1     2    2</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="co">#&gt; KATHERINE      2     1       2      1         0       1       1     2    2</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="co">#&gt; SYLVIA         2     2       3      2         1       1       2     2    3</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="co">#&gt; NORA           2     2       3      2         1       1       2     2    2</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17"><span class="co">#&gt; HELEN          1     2       2      2         1       1       2     1    2</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="co">#&gt; DOROTHY        2     1       2      1         0       1       1     2    2</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19"><span class="co">#&gt; OLIVIA         1     0       1      0         0       0       0     1    1</span></a>
<a class="sourceLine" id="cb3-20" data-line-number="20"><span class="co">#&gt; FLORA          1     0       1      0         0       0       0     1    1</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21"><span class="co">#&gt;           VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22"><span class="co">#&gt; EVELYN        2     2         2      2    2     1       2      1     1</span></a>
<a class="sourceLine" id="cb3-23" data-line-number="23"><span class="co">#&gt; LAURA         2     1         1      2    2     2       1      0     0</span></a>
<a class="sourceLine" id="cb3-24" data-line-number="24"><span class="co">#&gt; THERESA       3     2         2      3    3     2       2      1     1</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25"><span class="co">#&gt; BRENDA        2     1         1      2    2     2       1      0     0</span></a>
<a class="sourceLine" id="cb3-26" data-line-number="26"><span class="co">#&gt; CHARLOTTE     1     0         0      1    1     1       0      0     0</span></a>
<a class="sourceLine" id="cb3-27" data-line-number="27"><span class="co">#&gt; FRANCES       1     1         1      1    1     1       1      0     0</span></a>
<a class="sourceLine" id="cb3-28" data-line-number="28"><span class="co">#&gt; ELEANOR       2     1         1      2    2     2       1      0     0</span></a>
<a class="sourceLine" id="cb3-29" data-line-number="29"><span class="co">#&gt; PEARL         2     2         2      2    2     1       2      1     1</span></a>
<a class="sourceLine" id="cb3-30" data-line-number="30"><span class="co">#&gt; RUTH          3     2         2      3    2     2       2      1     1</span></a>
<a class="sourceLine" id="cb3-31" data-line-number="31"><span class="co">#&gt; VERNE         4     3         3      4    3     3       2      1     1</span></a>
<a class="sourceLine" id="cb3-32" data-line-number="32"><span class="co">#&gt; MYRNA         3     4         4      4    3     3       2      1     1</span></a>
<a class="sourceLine" id="cb3-33" data-line-number="33"><span class="co">#&gt; KATHERINE     3     4         6      6    5     3       2      1     1</span></a>
<a class="sourceLine" id="cb3-34" data-line-number="34"><span class="co">#&gt; SYLVIA        4     4         6      7    6     4       2      1     1</span></a>
<a class="sourceLine" id="cb3-35" data-line-number="35"><span class="co">#&gt; NORA          3     3         5      6    8     4       1      2     2</span></a>
<a class="sourceLine" id="cb3-36" data-line-number="36"><span class="co">#&gt; HELEN         3     3         3      4    4     5       1      1     1</span></a>
<a class="sourceLine" id="cb3-37" data-line-number="37"><span class="co">#&gt; DOROTHY       2     2         2      2    1     1       2      1     1</span></a>
<a class="sourceLine" id="cb3-38" data-line-number="38"><span class="co">#&gt; OLIVIA        1     1         1      1    2     1       1      2     2</span></a>
<a class="sourceLine" id="cb3-39" data-line-number="39"><span class="co">#&gt; FLORA         1     1         1      1    2     1       1      2     2</span></a></code></pre></div>
<p>From looking at the matrix of southern women above, we see that Evelyn and Charlotte have attended three of the same events. This means that <span class="math inline">\(G_{15} = 3\)</span> in the projection. In this vignette, we demonstrate using the backbone package to extract the backbone of <span class="math inline">\(G\)</span>, which involves deciding whether to preserve an edge between Evelyn and Charlotte in <span class="math inline">\(G’\)</span>, and similarly for all other edges in <span class="math inline">\(G\)</span>.</p>
</div>
</div>
<div id="general-backbone-methods" class="section level1">
<h1>General Backbone Methods</h1>
<p>In this section, we will describe backbone methods that can be applied to any weighted graph, whether the weights are present in a natively unipartite graph, or are the product of a bipartite projection (as is the case in our example data).</p>
<div id="universal-backbone-universal" class="section level2">
<h2>Universal Backbone: universal( )</h2>
<p>The simplest approach to backbone extraction applies a single threshold <span class="math inline">\(T\)</span> to all edges, and is achieved using the <code>universal()</code> function. The <code>universal()</code> function allows the user to extract a binary backbone by selecting a single threshold <span class="math inline">\(T\)</span>, or to extract a signed backbone by selecting upper and lower thresholds <span class="math inline">\(T\)</span> and <span class="math inline">\(T’\)</span>.</p>
<p>The <code>universal( )</code> function has six parameters,</p>
<ul>
<li>M, Matrix: a weighted adjacency matrix or a bipartite adjacency matrix</li>
<li>upper, Real: upper threshold value, to be multiplied by the result of FUN</li>
<li>lower, Real: lower threshold value, to be multiplied by the result of FUN</li>
<li>FUN, Function: A function to be applied to the edge weights, e.g. mean, sd, max, etc. The default is FUN = identity. If “identity”, the upper and lower parameter values are used for the threshold.</li>
<li>bipartite Boolean: TRUE if bipartite matrix, FALSE if weighted matrix. Default is FALSE.</li>
<li>by_row, Boolean: If bipartite = TRUE, whether the weighted graph should be constructed by projecting the bipartite data on the row vertices. If by_row = TRUE, the weighted graph and returned backbone will be a graph of the row vertices. If by_row = FALSE, the weighted graph and returned backbone will be a graph of the column vertices.</li>
</ul>
<p>The function <code>universal()</code> returns the backbone matrix, a signed (or binary) adjacency matrix of a graph. It has a variety of different uses which are demonstrated in the following examples. Using the <code>davis</code> dataset, if we input the projected matrix <code>G &lt;- davis%*%t(davis)</code>, we can use the universal threshold on the weighted matrix <code>G</code>. If we set an upper threshold of 1, then if two women have attended any event together, there will be an edge between the two. We can plot this graph with the <code>igraph</code> package.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">G &lt;-<span class="st"> </span>davis<span class="op">%*%</span><span class="kw">t</span>(davis) <span class="co">#projected davis dataset, a weighted graph</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">universal_bb &lt;-<span class="st"> </span><span class="kw">universal</span>(G, <span class="dt">upper =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">graph &lt;-<span class="st"> </span>igraph<span class="op">::</span><span class="kw">graph_from_adjacency_matrix</span>(universal_bb, <span class="dt">mode =</span> <span class="st">&quot;undirected&quot;</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">plot</span>(graph, <span class="dt">vertex.label =</span> <span class="ot">NA</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>We can also use the <code>universal()</code> function on the original bipartite data. When inputting bipartite data, we want to set parameter <code>bipartite = TRUE</code>. The bipartite matrix will be multiplied by its transpose before the threshold is applied. Below, we input the bipartite matrix <code>davis</code> with the same threshold values as before, returning the same backbone matrix.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1">universal_bb &lt;-<span class="st"> </span><span class="kw">universal</span>(davis, <span class="dt">upper =</span> <span class="dv">1</span>, <span class="dt">bipartite =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">graph &lt;-<span class="st"> </span>igraph<span class="op">::</span><span class="kw">graph_from_adjacency_matrix</span>(universal_bb, <span class="dt">mode =</span> <span class="st">&quot;undirected&quot;</span>)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">plot</span>(graph, <span class="dt">vertex.label =</span> <span class="ot">NA</span>)</a></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>To create a signed backbone, we can apply both an upper and lower threshold value. For instance, we could choose to retain a positive edge if the women attended at least 5 events together, and a negative edge if they only attended 1 event or less together. We can do this with the following code. Note that the returned backbone matrix now has both <span class="math inline">\(+1\)</span> and <span class="math inline">\(-1\)</span> values.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">universal_bb &lt;-<span class="st"> </span><span class="kw">universal</span>(davis, <span class="dt">upper =</span> <span class="dv">5</span>, <span class="dt">lower =</span> <span class="dv">1</span>, <span class="dt">bipartite =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">universal_bb</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="co">#&gt;           EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="co">#&gt; EVELYN         0     1       1      1         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="co">#&gt; LAURA          1     0       1      1         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="co">#&gt; THERESA        1     1       0      1         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="co">#&gt; BRENDA         1     1       1      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="co">#&gt; CHARLOTTE      0     0       0      0         0       0       0    -1    0</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="co">#&gt; FRANCES        0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="co">#&gt; ELEANOR        0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="co">#&gt; PEARL          0     0       0      0        -1       0       0     0    0</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="co">#&gt; RUTH           0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13"><span class="co">#&gt; VERNE          0     0       0      0        -1      -1       0     0    0</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"><span class="co">#&gt; MYRNA          0    -1       0     -1        -1      -1      -1     0    0</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="co">#&gt; KATHERINE      0    -1       0     -1        -1      -1      -1     0    0</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16"><span class="co">#&gt; SYLVIA         0     0       0      0        -1      -1       0     0    0</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17"><span class="co">#&gt; NORA           0     0       0      0        -1      -1       0     0    0</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18"><span class="co">#&gt; HELEN         -1     0       0      0        -1      -1       0    -1    0</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19"><span class="co">#&gt; DOROTHY        0    -1       0     -1        -1      -1      -1     0    0</span></a>
<a class="sourceLine" id="cb6-20" data-line-number="20"><span class="co">#&gt; OLIVIA        -1    -1      -1     -1        -1      -1      -1    -1   -1</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21"><span class="co">#&gt; FLORA         -1    -1      -1     -1        -1      -1      -1    -1   -1</span></a>
<a class="sourceLine" id="cb6-22" data-line-number="22"><span class="co">#&gt;           VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA</span></a>
<a class="sourceLine" id="cb6-23" data-line-number="23"><span class="co">#&gt; EVELYN        0     0         0      0    0    -1       0     -1    -1</span></a>
<a class="sourceLine" id="cb6-24" data-line-number="24"><span class="co">#&gt; LAURA         0    -1        -1      0    0     0      -1     -1    -1</span></a>
<a class="sourceLine" id="cb6-25" data-line-number="25"><span class="co">#&gt; THERESA       0     0         0      0    0     0       0     -1    -1</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26"><span class="co">#&gt; BRENDA        0    -1        -1      0    0     0      -1     -1    -1</span></a>
<a class="sourceLine" id="cb6-27" data-line-number="27"><span class="co">#&gt; CHARLOTTE    -1    -1        -1     -1   -1    -1      -1     -1    -1</span></a>
<a class="sourceLine" id="cb6-28" data-line-number="28"><span class="co">#&gt; FRANCES      -1    -1        -1     -1   -1    -1      -1     -1    -1</span></a>
<a class="sourceLine" id="cb6-29" data-line-number="29"><span class="co">#&gt; ELEANOR       0    -1        -1      0    0     0      -1     -1    -1</span></a>
<a class="sourceLine" id="cb6-30" data-line-number="30"><span class="co">#&gt; PEARL         0     0         0      0    0    -1       0     -1    -1</span></a>
<a class="sourceLine" id="cb6-31" data-line-number="31"><span class="co">#&gt; RUTH          0     0         0      0    0     0       0     -1    -1</span></a>
<a class="sourceLine" id="cb6-32" data-line-number="32"><span class="co">#&gt; VERNE         0     0         0      0    0     0       0     -1    -1</span></a>
<a class="sourceLine" id="cb6-33" data-line-number="33"><span class="co">#&gt; MYRNA         0     0         0      0    0     0       0     -1    -1</span></a>
<a class="sourceLine" id="cb6-34" data-line-number="34"><span class="co">#&gt; KATHERINE     0     0         0      1    1     0       0     -1    -1</span></a>
<a class="sourceLine" id="cb6-35" data-line-number="35"><span class="co">#&gt; SYLVIA        0     0         1      0    1     0       0     -1    -1</span></a>
<a class="sourceLine" id="cb6-36" data-line-number="36"><span class="co">#&gt; NORA          0     0         1      1    0     0      -1      0     0</span></a>
<a class="sourceLine" id="cb6-37" data-line-number="37"><span class="co">#&gt; HELEN         0     0         0      0    0     0      -1     -1    -1</span></a>
<a class="sourceLine" id="cb6-38" data-line-number="38"><span class="co">#&gt; DOROTHY       0     0         0      0   -1    -1       0     -1    -1</span></a>
<a class="sourceLine" id="cb6-39" data-line-number="39"><span class="co">#&gt; OLIVIA       -1    -1        -1     -1    0    -1      -1      0     0</span></a>
<a class="sourceLine" id="cb6-40" data-line-number="40"><span class="co">#&gt; FLORA        -1    -1        -1     -1    0    -1      -1      0     0</span></a></code></pre></div>
<p>We can also choose a threshold that is a multiple of some function, such as mean, max, or min. The function is applied to the edge weights, and then multiplied by the upper and lower thresholds. Any <span class="math inline">\(G_{ij}\)</span> values above the upper threshold are counted as a positive <span class="math inline">\(+1\)</span> value in the backbone, and any below the lower threshold are counted as a negative <span class="math inline">\(-1\)</span> value in the backbone. The following code will return a backbone where the positive edges indicate two women attended more than 2 standard deviations above the mean number of events.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">universal_bb &lt;-<span class="st"> </span><span class="kw">universal</span>(davis, <span class="dt">upper =</span> <span class="dv">1</span>, <span class="dt">FUN =</span> <span class="cf">function</span>(x){<span class="kw">mean</span>(x)<span class="op">+</span><span class="dv">2</span><span class="op">*</span><span class="kw">sd</span>(x)}, <span class="dt">bipartite =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<p>Here, the <code>davis</code> matrix has first been projected. Then, the mean of the <span class="math inline">\(G_{ij}\)</span> entries is calculated and added to twice the standard deviation of the <span class="math inline">\(G_{ij}\)</span> values. This value is multiplied by the upper 1, and then used to threshold the projected matrix for the positive entries.</p>
</div>
</div>
<div id="bipartite-projection-backbone-methods" class="section level1">
<h1>Bipartite Projection Backbone Methods</h1>
<p><span class="citation">(Neal <a href="#ref-neal2014backbone">2014</a>)</span></p>
<p>The methods described above can be applied to any weighted graph <span class="math inline">\(G\)</span>. In this section we describe methods that are designed for weighted graphs that are the result of bipartite projections. They differ from other methods because they take into account the information contained in the original bipartite graph <span class="math inline">\(B\)</span>. Specifically, these methods are conditioned on the bipartite graph’s two degree sequences: the row vertex degrees (i.e. row marginals) and column vertex degrees (i.e. column marginals). Each method follows the same basic algorithm:</p>
<ol style="list-style-type: decimal">
<li>Construct a random bipartite graph <span class="math inline">\(B^*\)</span> that preserves (to varying extents, depending on the method) one or both degree sequences <span class="citation">(Strona, Ulrich, and Gotelli <a href="#ref-strona2018bi">2018</a>)</span>.</li>
<li>Project <span class="math inline">\(B^*\)</span> (i.e. <span class="math inline">\(B^{*} B^{*’}\)</span>) to obtain a random weighted bipartite projection <span class="math inline">\(G^*\)</span></li>
<li>Repeat steps 1 and 2 <span class="math inline">\(N\)</span> times to build a distribution of <span class="math inline">\(G^*_{ij}\)</span></li>
<li>Compare <span class="math inline">\(G_{ij}\)</span> to the distribution of <span class="math inline">\(G^*_{ij}\)</span>. Define a binary backbone <span class="math inline">\(G’\)</span> such that <span class="math inline">\(G’_{ij}=1\)</span> if <span class="math inline">\(G^*_{ij}\)</span> is larger than <span class="math inline">\(G_{ij}\)</span> in no more than <span class="math inline">\(\alpha \times N\)</span> cases, and otherwise is 0. Or define a signed backbone <span class="math inline">\(G’\)</span> such that <span class="math inline">\(G’_{ij}=1\)</span> if <span class="math inline">\(G^*_{ij}\)</span> is larger than <span class="math inline">\(G_{ij}\)</span> in no more than <span class="math inline">\((\alpha / 2) \times N\)</span> cases, that <span class="math inline">\(G’_{ij}=-1\)</span> if <span class="math inline">\(G^*_{ij}\)</span> is smaller than <span class="math inline">\(G_{ij}\)</span> in no more than <span class="math inline">\((\alpha / 2) \times N\)</span> cases, and otherwise is 0.</li>
</ol>
<p>The backbone package implements three ways to perform steps 1-3, counting the proportion of times <span class="math inline">\(G^*_{ij}\)</span> it was larger or smaller than <span class="math inline">\(G_{ij}\)</span>: the hypergeometric distribution using <code>hyperg()</code>, the fixed degree sequence method using <code>fdsm()</code>, and the stochastic degree sequence method using <code>sdsm()</code>. From these counts, the backbone can then be extracted for a given <span class="math inline">\(\alpha\)</span> level using the <code>backbone.extract()</code> function. In this section, we first describe <code>backbone.extract()</code>, then illustrate its use in the context of <code>hyperg(), fdsm(),</code> and <code>sdsm()</code>.</p>
<div id="extracting-the-backbone-backbone.extract" class="section level2">
<h2>Extracting the Backbone: backbone.extract( )</h2>
<p>The <code>hyperg(), fdsm(),</code> and <code>sdsm()</code> functions return two matrices: a positive matrix containing the number of times <span class="math inline">\(G^*_{ij}\)</span> it was larger than <span class="math inline">\(G_{ij}\)</span>, and a negative matrix containing the number of times <span class="math inline">\(G^*_{ij}\)</span> it was smaller than <span class="math inline">\(G_{ij}\)</span>. The <code>backbone.extract()</code> function allows the user to take these positive and negative matrices and return a binary or signed backbone.</p>
<p>The <code>backbone.extract()</code> function parameters are two matrices, <code>positive</code> and <code>negative</code>, and a significant test value <code>alpha</code>. The matrices should be the number of times the projected matrix values <span class="math inline">\(P_{ij}\)</span> were above (in the positive matrix) or below (in the negative matrix) the corresponding entry in one of the matrices generated by <code>hyperg(), fdsm()</code>, or <code>sdsm()</code>, divided by the total number of matrices generated.</p>
<p>One can adjust the precision of the significance test, <code>alpha</code>, to refine their backbone results. The value of <code>alpha</code> should be between <code>0</code> and <code>1</code>. The default is <code>alpha=0.05</code>. If only the <code>positive</code> matrix is supplied to the function (i.e. <code>negative</code> = NULL), then the <code>alpha</code> value is equal to the user’s input, and the statistical test is one-tailed yielding a binary backbone. If the <code>negative</code> matrix is also supplied to the function, the <code>alpha</code> value is equal to the user’s input divided by two, and the statistical test is two-tailed yielding a signed backbone.</p>
<p>The <code>backbone.extract()</code> function will return a backbone matrix. If an entry in the <code>positive</code> matrix is greater than the <code>alpha</code> value, it is considered a positive <code>+1</code> edge in the backbone. If an entry in the <code>negative</code> matrix is greater than the <code>alpha</code> value, it is considered a <code>-1</code> edge in the backbone. If only the <code>positive</code> matrix is inputted, a binary backbone is returned.</p>
<p>We demonstrate this function’s use in the following sections.</p>
</div>
<div id="hypergeometric-backbone-hyperg" class="section level2">
<h2>Hypergeometric Backbone: hyperg( )</h2>
<p>The hypergeometric distribution compares an edge’s observed weight, <span class="math inline">\(G_{ij}\)</span> to the distribution of weights expected in a projection obtained from a random bipartite network where the row vertex degrees are fixed, but the column vertex degrees are allowed to vary. This method of backbone extraction was developed in <span class="citation">(Neal <a href="#ref-neal2013identifying">2013</a>)</span>, which showed that the distribution of <span class="math inline">\(G^*_{ij}\)</span> when only vertex degrees are fixed is given by the hypergeometric distribution and does not require simulation using steps 1-3 shown above. . For documentation on the hypergeometric distribution, see <code>stats::phyper</code>.</p>
<p>The <code>hyperg()</code> function has two parameters,</p>
<ul>
<li>B, Matrix: Bipartite adjacency matrix</li>
<li>by_row, Boolean: If function should evaluate the bipartite matrix by row or column. If by_row = TRUE, the weighted graph and returned backbone will be a graph of the row vertices. If by_row = FALSE, the weighted graph and returned backbone will be a graph of the column vertices. The default is set to TRUE.</li>
</ul>
<p>The <code>hyperg()</code> function returns a list of the following:</p>
<ul>
<li>positive: matrix of the proportion of times <span class="math inline">\(G_{ij}\)</span> is above the corresponding entry in <span class="math inline">\(G^*\)</span></li>
<li>negative: matrix of the proportion of times <span class="math inline">\(G_{ij}\)</span> is below the corresponding entry in <span class="math inline">\(G^*\)</span></li>
</ul>
<p>Following the <code>hyperg()</code> function, the user must use the <code>backbone.extract()</code> function to find the backbone at a given significance value <code>alpha</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">hyperg_probs &lt;-<span class="st"> </span><span class="kw">hyperg</span>(davis)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">#&gt; [1] &quot;Finding the Backbone using Hypergeometric Distribution&quot;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">hyperg_bb &lt;-<span class="st"> </span><span class="kw">backbone.extract</span>(hyperg_probs<span class="op">$</span>positive, hyperg_probs<span class="op">$</span>negative)</a></code></pre></div>
</div>
<div id="the-fixed-degree-sequence-model-fdsm" class="section level2">
<h2>The Fixed Degree Sequence Model: fdsm( )</h2>
<p>The fixed degree sequence model compares an edge’s observed weight, <span class="math inline">\(G_{ij}\)</span> to the distribution of weights expected in a projection obtained from a random bipartite network where both the row vertex degrees and column vertex degrees are fixed. This method of backbone extraction was developed in <span class="citation">(Zweig and Kaufmann <a href="#ref-zweig2011systematic">2011</a>)</span>, however the challenge lies in randomly sampling from the space of <span class="math inline">\(B^*\)</span> with fixed degree sequences. The <code>fdsm()</code> function uses the curveball algorithm <span class="citation">(Strona et al. <a href="#ref-strona2014fast">2014</a>)</span>, which is believed (but not proven) to do so.</p>
<p>The <code>fdsm( )</code> function has five parameters,</p>
<ul>
<li>B, Matrix: Bipartite adjacency matrix</li>
<li>trials, Integer: Number of random bipartite graphs generated</li>
<li>by_row, Boolean: If function should evaluate the bipartite matrix by row or column. If by_row = TRUE, the weighted graph and returned backbone will be a graph of the row vertices. If by_row = FALSE, the weighted graph and returned backbone will be a graph of the column vertices. The default is set to TRUE.</li>
<li>sparse, Boolean: If sparse matrix manipulations should be used</li>
<li>dyad, vector length 2: two row entries i,j. Saves each value of <span class="math inline">\(G^*_{ij}\)</span>, which is useful for visualizing an example of the empirical null edge weight distribution generated by the model. These correspond to the row and column indices of a cell in the projected matrix , and can be written as their string row names or as numeric values.</li>
</ul>
<p>The <code>fdsm()</code> function returns a list of the following:</p>
<ul>
<li>positive: matrix of the proportion of times <span class="math inline">\(G_{ij}\)</span> is above the corresponding entry in <span class="math inline">\(G^*\)</span></li>
<li>negative: matrix of the proportion of times <span class="math inline">\(G_{ij}\)</span> is below the corresponding entry in <span class="math inline">\(G^*\)</span></li>
<li>dyad_values: list of edge weights for <span class="math inline">\(i,j\)</span> in each <span class="math inline">\(G^*\)</span></li>
</ul>
<p>We can find the backbone using the fixed degree sequence model as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">fdsm_props &lt;-<span class="st"> </span><span class="kw">fdsm</span>(davis, <span class="dt">trials =</span> <span class="dv">100</span>, <span class="dt">by_row =</span> <span class="ot">TRUE</span>, <span class="dt">sparse =</span> <span class="ot">TRUE</span>, <span class="dt">dyad=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">5</span>))</a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">fdsm_props<span class="op">$</span>dyad</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">#&gt;   [1] 3 3 2 3 4 3 2 2 1 3 3 2 2 3 3 2 3 2 4 2 2 3 4 3 3 2 2 2 1 3 3 2 3 2 3</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="co">#&gt;  [36] 2 1 3 3 3 3 3 3 3 2 3 2 2 2 3 4 3 3 2 3 3 2 2 2 3 3 3 2 3 4 3 3 3 2 2</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="co">#&gt;  [71] 3 2 2 3 3 4 3 3 4 2 3 4 4 3 4 3 3 3 2 2 2 3 3 2 3 2 3 2 2 3</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">fdsm_bb &lt;-<span class="st"> </span><span class="kw">backbone.extract</span>(fdsm_props<span class="op">$</span>positive, fdsm_props<span class="op">$</span>negative, <span class="dt">alpha =</span> <span class="fl">0.05</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">fdsm_bb</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">#&gt;           EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="co">#&gt; EVELYN         0     1       1      1         0       1       0     1    0</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="co">#&gt; LAURA          1     0       1      1         0       1       1     0    0</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10"><span class="co">#&gt; THERESA        1     1       0      1         1       1       1     1    1</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="co">#&gt; BRENDA         1     1       1      0         1       1       1     0    0</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="co">#&gt; CHARLOTTE      0     0       1      1         0       0       0    -1    0</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="co">#&gt; FRANCES        1     1       1      1         0       0       1     0    0</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="co">#&gt; ELEANOR        0     1       1      1         0       1       0     0    1</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">#&gt; PEARL          1     0       1      0        -1       0       0     0    1</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"><span class="co">#&gt; RUTH           0     0       1      0         0       0       1     1    0</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="co">#&gt; VERNE          0     0       0      0         0       0       0     0    1</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="co">#&gt; MYRNA          0    -1       0     -1        -1       0       0     0    0</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="co">#&gt; KATHERINE     -1    -1      -1     -1        -1      -1      -1     0    0</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20"><span class="co">#&gt; SYLVIA        -1    -1       0     -1        -1      -1       0     0    0</span></a>
<a class="sourceLine" id="cb10-21" data-line-number="21"><span class="co">#&gt; NORA          -1    -1      -1     -1        -1      -1       0     0    0</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22"><span class="co">#&gt; HELEN         -1     0       0     -1         0      -1       0     0    0</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23"><span class="co">#&gt; DOROTHY        1     0       1      0        -1       0       0     1    1</span></a>
<a class="sourceLine" id="cb10-24" data-line-number="24"><span class="co">#&gt; OLIVIA         0    -1       0     -1        -1      -1      -1     0    0</span></a>
<a class="sourceLine" id="cb10-25" data-line-number="25"><span class="co">#&gt; FLORA          0    -1       0     -1        -1      -1      -1     0    0</span></a>
<a class="sourceLine" id="cb10-26" data-line-number="26"><span class="co">#&gt;           VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA</span></a>
<a class="sourceLine" id="cb10-27" data-line-number="27"><span class="co">#&gt; EVELYN        0     0        -1     -1   -1    -1       1      0     0</span></a>
<a class="sourceLine" id="cb10-28" data-line-number="28"><span class="co">#&gt; LAURA         0    -1        -1     -1   -1     0       0     -1    -1</span></a>
<a class="sourceLine" id="cb10-29" data-line-number="29"><span class="co">#&gt; THERESA       0     0        -1      0   -1     0       1      0     0</span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30"><span class="co">#&gt; BRENDA        0    -1        -1     -1   -1    -1       0     -1    -1</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31"><span class="co">#&gt; CHARLOTTE     0    -1        -1     -1   -1     0      -1     -1    -1</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32"><span class="co">#&gt; FRANCES       0     0        -1     -1   -1    -1       0     -1    -1</span></a>
<a class="sourceLine" id="cb10-33" data-line-number="33"><span class="co">#&gt; ELEANOR       0     0        -1      0    0     0       0     -1    -1</span></a>
<a class="sourceLine" id="cb10-34" data-line-number="34"><span class="co">#&gt; PEARL         0     0         0      0    0     0       1      0     0</span></a>
<a class="sourceLine" id="cb10-35" data-line-number="35"><span class="co">#&gt; RUTH          1     0         0      0    0     0       1      0     0</span></a>
<a class="sourceLine" id="cb10-36" data-line-number="36"><span class="co">#&gt; VERNE         0     1         0      1    0     1       1      0     0</span></a>
<a class="sourceLine" id="cb10-37" data-line-number="37"><span class="co">#&gt; MYRNA         1     0         1      1    0     1       1      0     0</span></a>
<a class="sourceLine" id="cb10-38" data-line-number="38"><span class="co">#&gt; KATHERINE     0     1         0      1    1     0       1      0     0</span></a>
<a class="sourceLine" id="cb10-39" data-line-number="39"><span class="co">#&gt; SYLVIA        1     1         1      0    1     0       1      0     0</span></a>
<a class="sourceLine" id="cb10-40" data-line-number="40"><span class="co">#&gt; NORA          0     0         1      1    0     0       0      1     1</span></a>
<a class="sourceLine" id="cb10-41" data-line-number="41"><span class="co">#&gt; HELEN         1     1         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb10-42" data-line-number="42"><span class="co">#&gt; DOROTHY       1     1         1      1    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb10-43" data-line-number="43"><span class="co">#&gt; OLIVIA        0     0         0      0    1     0       0      0     1</span></a>
<a class="sourceLine" id="cb10-44" data-line-number="44"><span class="co">#&gt; FLORA         0     0         0      0    1     0       0      1     0</span></a></code></pre></div>
<p>This returns a list of the <span class="math inline">\(G_{1,5}^*\)</span> values for each of the 100 trials, which in these data corresponds to the number of parties Evelyn and Charlotte would be expected to simultaneously attend if: (a) the number of parties attended by Evelyn was fixed, (b) the number of parties attended by Charlotte was fixed, and (c) the number of attendees at each party was fixed. Because we have provided both a <code>positive</code> and <code>negative</code> matrix, backbone.extract() returns a signed backbone matrix by conducting a two-tailed significance test in which <code>alpha</code> is <span class="math inline">\(0.025\)</span> on each end of the distribution.</p>
</div>
<div id="the-stochastic-degree-sequence-model-sdsm" class="section level2">
<h2>The Stochastic Degree Sequence Model: sdsm( )</h2>
<p>The stochastic degree sequence model compares an edge’s observed weight, <span class="math inline">\(G_{ij}\)</span> to the distribution of weights expected in a projection obtained from a random bipartite network where both the row vertex degrees and column vertex degrees are <em>approximately</em> fixed. This method of backbone extraction was developed in <span class="citation">(Neal <a href="#ref-neal2014backbone">2014</a>)</span>. The construction of <span class="math inline">\(B^*\)</span> involves a series of steps:</p>
<ol style="list-style-type: decimal">
<li>The <span class="math inline">\(\beta\)</span> parameters in <span class="math inline">\(Pr(B_{ij}=1) = \beta_0 +\beta_1 B_i + \beta_2 B_j +\beta_3 (B_i \times B_j)\)</span> are estimated using a binomial regression (e.g. logit, probit, complementary log-log, etc.), where <span class="math inline">\(B_i\)</span> and <span class="math inline">\(B_j\)</span> are the row vertex and column vertex degrees in <span class="math inline">\(B\)</span>, respectively.</li>
<li>The fitted parameters are used to compute the predicted probability that <span class="math inline">\(B_{ij}=1\)</span>.</li>
<li><span class="math inline">\(B^*\)</span> is constructed such that <span class="math inline">\(B_{ij}^*\)</span> is the outcome of a single Bernouilli trial with <span class="math inline">\(Pr(B_{ij}=1)\)</span> probability of success.</li>
</ol>
<p>The <code>sdsm( )</code> function has seven parameters,</p>
<ul>
<li>B, Matrix: Bipartite adjacency matrix</li>
<li>trials, Integer: Number of random bipartite graphs generated</li>
<li>model, String: A generalized linear model (glm) used to generate random bipartite graphs. The <code>model</code> parameter can take in a <code>link</code> function, as described by the <code>stats</code> package under <code>stats::glm</code> and <code>stats::family</code>. This can be one of <code>c('logit', 'probit', 'cauchit', 'log', 'cloglog')</code>.</li>
<li>by_row, Boolean: If function should evaluate the bipartite matrix by row or column. If by_row = TRUE, the weighted graph and returned backbone will be a graph of the row vertices. If by_row = FALSE, the weighted graph and returned backbone will be a graph of the column vertices. The default is set to TRUE.</li>
<li>sparse, Boolean: If sparse matrix manipulations should be used</li>
<li>maxiter, Integer: Maximum number of iterations if “model” is a glm.</li>
<li>dyad, vector length 2: two row entries i,j. Saves each value of <span class="math inline">\(G^*_{ij}\)</span>, which is useful for visualizing an example of the empirical null edge weight distribution generated by the model. These correspond to the row and column indices of a cell in the projected matrix , and can be written as their string row names or as numeric values.</li>
</ul>
<p>The <code>sdsm()</code> function returns a list of the following:</p>
<ul>
<li>positive: matrix of the proportion of times <span class="math inline">\(G_{ij}\)</span> is above the corresponding entry in <span class="math inline">\(G^*\)</span></li>
<li>negative: matrix of the proportion of times <span class="math inline">\(G_{ij}\)</span> is below the corresponding entry in <span class="math inline">\(G^*\)</span></li>
<li>dyad_values: list of edge weights for <span class="math inline">\(i,j\)</span> in each <span class="math inline">\(G^*\)</span></li>
</ul>
<p>We can find the backbone via the sdsm method as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">sdsm_props &lt;-<span class="st"> </span><span class="kw">sdsm</span>(davis, <span class="dt">trials =</span> <span class="dv">100</span>,<span class="dt">dyad =</span> <span class="kw">c</span>(<span class="st">&quot;EVELYN&quot;</span>, <span class="st">&quot;CHARLOTTE&quot;</span>)) </a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">sdsm_props<span class="op">$</span>dyad</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="co">#&gt;   [1] 2 1 2 2 1 2 3 3 2 2 2 0 3 3 1 3 2 3 2 5 3 3 1 4 3 4 1 6 4 3 6 2 4 1 2</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="co">#&gt;  [36] 3 1 3 3 2 2 3 4 2 1 2 3 3 1 4 2 0 3 2 2 1 5 1 2 3 4 4 4 4 4 2 2 4 4 2</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="co">#&gt;  [71] 5 3 1 3 1 1 1 3 3 3 4 1 3 3 1 3 3 4 2 0 1 2 1 4 2 6 1 2 1 1</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">sdsm_bb &lt;-<span class="st"> </span><span class="kw">backbone.extract</span>(sdsm_props<span class="op">$</span>positive, <span class="dt">alpha =</span> <span class="fl">0.05</span>) </a>
<a class="sourceLine" id="cb12-6" data-line-number="6">sdsm_bb</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="co">#&gt;           EVELYN LAURA THERESA BRENDA CHARLOTTE FRANCES ELEANOR PEARL RUTH</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="co">#&gt; EVELYN         0     0       1      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="co">#&gt; LAURA          0     0       0      1         0       1       0     0    0</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="co">#&gt; THERESA        1     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="co">#&gt; BRENDA         0     1       0      0         1       1       0     0    0</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="co">#&gt; CHARLOTTE      0     0       0      1         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="co">#&gt; FRANCES        0     1       0      1         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="co">#&gt; ELEANOR        0     0       0      0         0       0       0     0    1</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"><span class="co">#&gt; PEARL          0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"><span class="co">#&gt; RUTH           0     0       0      0         0       0       1     0    0</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17"><span class="co">#&gt; VERNE          0     0       0      0         0       0       0     0    1</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18"><span class="co">#&gt; MYRNA          0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19"><span class="co">#&gt; KATHERINE      0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-20" data-line-number="20"><span class="co">#&gt; SYLVIA         0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21"><span class="co">#&gt; NORA           0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-22" data-line-number="22"><span class="co">#&gt; HELEN          0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-23" data-line-number="23"><span class="co">#&gt; DOROTHY        0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-24" data-line-number="24"><span class="co">#&gt; OLIVIA         0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-25" data-line-number="25"><span class="co">#&gt; FLORA          0     0       0      0         0       0       0     0    0</span></a>
<a class="sourceLine" id="cb12-26" data-line-number="26"><span class="co">#&gt;           VERNE MYRNA KATHERINE SYLVIA NORA HELEN DOROTHY OLIVIA FLORA</span></a>
<a class="sourceLine" id="cb12-27" data-line-number="27"><span class="co">#&gt; EVELYN        0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-28" data-line-number="28"><span class="co">#&gt; LAURA         0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-29" data-line-number="29"><span class="co">#&gt; THERESA       0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-30" data-line-number="30"><span class="co">#&gt; BRENDA        0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-31" data-line-number="31"><span class="co">#&gt; CHARLOTTE     0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-32" data-line-number="32"><span class="co">#&gt; FRANCES       0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-33" data-line-number="33"><span class="co">#&gt; ELEANOR       0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-34" data-line-number="34"><span class="co">#&gt; PEARL         0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-35" data-line-number="35"><span class="co">#&gt; RUTH          1     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36"><span class="co">#&gt; VERNE         0     1         0      1    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-37" data-line-number="37"><span class="co">#&gt; MYRNA         1     0         1      1    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-38" data-line-number="38"><span class="co">#&gt; KATHERINE     0     1         0      1    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-39" data-line-number="39"><span class="co">#&gt; SYLVIA        1     1         1      0    0     1       0      0     0</span></a>
<a class="sourceLine" id="cb12-40" data-line-number="40"><span class="co">#&gt; NORA          0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-41" data-line-number="41"><span class="co">#&gt; HELEN         0     0         0      1    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-42" data-line-number="42"><span class="co">#&gt; DOROTHY       0     0         0      0    0     0       0      0     0</span></a>
<a class="sourceLine" id="cb12-43" data-line-number="43"><span class="co">#&gt; OLIVIA        0     0         0      0    0     0       0      0     1</span></a>
<a class="sourceLine" id="cb12-44" data-line-number="44"><span class="co">#&gt; FLORA         0     0         0      0    0     0       0      1     0</span></a></code></pre></div>
<p>This returns a list of the <span class="math inline">\(G_{Evelyn,Charlotte}^*\)</span> values for each of the 100 trials, which in these data corresponds to the number of parties Evelyn and Charlotte would be expected to simultaneously attend if: (a) the number of parties attended by Evelyn was approximately fixed, (b) the number of parties attended by Charlotte was approximately fixed, and (c) the number of attendees at each party was approximately fixed. Because we have provided only a <code>positive</code> matrix, backbone.extract() returns a binary backbone matrix by conducting a one-tailed significance test in which <code>alpha</code> is <span class="math inline">\(0.05\)</span>.</p>
</div>
</div>
<div id="future" class="section level1">
<h1>Future</h1>
<p>The <code>backbone</code> package will be updated to contain additional backbone extraction methods that are used in the current literature.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-davis1941deep">
<p>Davis, Allison, Burleigh B Gardner, and Mary R Gardner. 1941. “Deep South. The U.” of Chicago Press, Chicago, IL.</p>
</div>
<div id="ref-neal2013identifying">
<p>Neal, Zachary. 2013. “Identifying Statistically Significant Edges in One-Mode Projections.” <em>Social Network Analysis and Mining</em> 3 (4). Springer: 915–24.</p>
</div>
<div id="ref-neal2014backbone">
<p>———. 2014. “The Backbone of Bipartite Projections: Inferring Relationships from Co-Authorship, Co-Sponsorship, Co-Attendance and Other Co-Behaviors.” <em>Social Networks</em> 39. Elsevier: 84–97.</p>
</div>
<div id="ref-ucinet">
<p>Repository, UCI Network Data. n.d. “Southern Women Data Set.” <a href="https://networkdata.ics.uci.edu/netdata/html/davis.html" class="uri">https://networkdata.ics.uci.edu/netdata/html/davis.html</a>.</p>
</div>
<div id="ref-strona2014fast">
<p>Strona, Giovanni, Domenico Nappo, Francesco Boccacci, Simone Fattorini, and Jesus San-Miguel-Ayanz. 2014. “A Fast and Unbiased Procedure to Randomize Ecological Binary Matrices with Fixed Row and Column Totals.” <em>Nature Communications</em> 5. Nature Publishing Group: 4114.</p>
</div>
<div id="ref-strona2018bi">
<p>Strona, Giovanni, Werner Ulrich, and Nicholas J Gotelli. 2018. “Bi-Dimensional Null Model Analysis of Presence-Absence Binary Matrices.” <em>Ecology</em> 99 (1). Wiley Online Library: 103–15.</p>
</div>
<div id="ref-zweig2011systematic">
<p>Zweig, Katharina Anna, and Michael Kaufmann. 2011. “A Systematic Approach to the One-Mode Projection of Bipartite Graphs.” <em>Social Network Analysis and Mining</em> 1 (3). Springer: 187–218.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
