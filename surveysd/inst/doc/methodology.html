<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Methodology</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>





<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Methodology</h1>



<p>In the following we present the methodology in <code>surveysd</code> by applying the workflow described in <code>vignette(&quot;surveysd&quot;)</code> to multiple consecutive years of EU-SILC data for one country. The methodology contains the following steps, in this order</p>
<ul>
<li>Draw <span class="math inline">\(B\)</span> bootstrap replicates from EU-SILC data for each year <span class="math inline">\(y_t\)</span>, <span class="math inline">\(t=1,\ldots,n_y\)</span> separately. Since EU-SILC has a rotating panel design the bootstrap replicate of a household is carried forward through the years. That is, the bootstrap replicate of a household in the follow-up years is set equal to the bootstrap replicate of the same household when it first enters EU-SILC.</li>
<li>Multiply each set of bootstrap replicates by the sampling weights to obtain uncalibrated bootstrap weights and calibrate each of the uncalibrated bootstrap weights using iterative proportional fitting.</li>
<li>Estimate the point estimate of interest <span class="math inline">\(\theta\)</span>, for each year and each calibrated bootstrap weight to obtain <span class="math inline">\(\tilde{\theta}^{(i,y_t)}\)</span>, <span class="math inline">\(t=1,\ldots,n_y\)</span>, <span class="math inline">\(i=1,\ldots,B\)</span>. For fixed <span class="math inline">\(y_t\)</span> apply a filter with equal weights for each <span class="math inline">\(i\)</span> on <span class="math inline">\(\tilde{\theta}^{(i,y^*)}\)</span>, <span class="math inline">\(y^*\in \{y_{t-1},y_{t},y_{t+1}\}\)</span> , to obtain <span class="math inline">\(\tilde{\theta}^{(i,y_t)}\)</span>. Estimate the variance of <span class="math inline">\(\theta\)</span> using the distribution of <span class="math inline">\(\tilde{\theta}^{(i,y_t)}\)</span>.</li>
</ul>
<div id="bootstrapping" class="section level2">
<h2>Bootstrapping</h2>
<p>Bootstrapping has long been around and used widely to estimate confidence intervals and standard errors of point estimates.[<span class="citation">Efron (1979)</span>} Given a random sample <span class="math inline">\((X_1,\ldots,X_n)\)</span> drawn from an unknown distribution <span class="math inline">\(F\)</span> the distribution of a point estimate <span class="math inline">\(\theta(X_1,\ldots,X_n;F)\)</span> can in many cases not be determined analytically. However when using bootstrapping one can simulate the distribution of <span class="math inline">\(\theta\)</span>.</p>
<p>Let <span class="math inline">\(s_{(.)}\)</span> be a bootstrap sample, e.g. drawing <span class="math inline">\(n\)</span> observations with replacement from the sample <span class="math inline">\((X_1,\ldots,X_n)\)</span>, then one can estimate the standard deviation of <span class="math inline">\(\theta\)</span> using <span class="math inline">\(B\)</span> bootstrap samples through <span class="math display">\[sd(\theta) = \sqrt{\frac{1}{B-1}\sum\limits_{i=1}^B (\theta(s_i)-\overline{\theta})^2} \quad, \]</span></p>
<p>with <span class="math inline">\(\overline{\theta}:=\frac{1}{B}\sum\limits_{i=1}^B\theta(s_i)\)</span> as the sample mean over all bootstrap samples.</p>
<p>In context of sample surveys with sampling weights one can use bootstrapping to calculate so called bootstrap weights. These are computed via the bootstrap samples <span class="math inline">\(s_{i}\)</span>, <span class="math inline">\(i=1,\ldots,B\)</span>, where for each <span class="math inline">\(s_{i}\)</span> every unit of the original sample can appear <span class="math inline">\(0\)</span>- to <span class="math inline">\(m\)</span>-times. With <span class="math inline">\(f_j^{i}\)</span> as the frequency of occurrence of observation <span class="math inline">\(j\)</span> in bootstrap sample <span class="math inline">\(s_i\)</span> the uncalibrated bootstrap weights <span class="math inline">\(\tilde{b}_{j}^{i}\)</span> are defined as:</p>
<p><span class="math display">\[
  \tilde{b}_{j}^{i} = f_j^{i} w_j \quad,
\]</span></p>
<p>with <span class="math inline">\(w_j\)</span> as the calibrated sampling weight of the original sample. Using iterative proportional fitting procedures one can recalibrate the bootstrap weights <span class="math inline">\(\tilde{b}_{j}^{.}\)</span>, <span class="math inline">\(j=1,\ldots,B\)</span> to get the adapted or calibrated bootstrap weights <span class="math inline">\(b_j^i\)</span>, <span class="math inline">\(j=1,\ldots,B\)</span>.</p>
<div id="rescaled-bootstrap" class="section level3">
<h3>Rescaled Bootstrap</h3>
<p>Since EU-SILC is a stratified sample without replacement drawn from a finite population the naive bootstrap procedure, as described above, does not take into account the heterogeneous inclusion probabilities of each sample unit. Thus it will not yield satisfactory results. Therefore we will use the so called rescaled bootstrap procedure introduced and investigated by <span class="citation">(Rao and Wu 1988)</span>. The bootstrap samples are selected without replacement and do incorporate the stratification as well as clustering on multiple stages (see <span class="citation">(Chipperfield and Preston 2007)</span>,<span class="citation">(Preston 2009)</span>).</p>
<p>For simplistic reasons we will only describe the rescaled bootstrap procedure for a two stage stratified sampling design. For more details on a general formulation please see <span class="citation">(Preston 2009)</span>.</p>
</div>
<div id="sampling-design" class="section level3">
<h3>Sampling design</h3>
<p>Consider the finite population <span class="math inline">\(U\)</span> which is divided into <span class="math inline">\(H\)</span> non-overlapping strata <span class="math inline">\(\bigcup\limits_{h=1,\ldots,H} U_h = U\)</span>, of which each strata <span class="math inline">\(h\)</span> contains of <span class="math inline">\(N_h\)</span> clusters. For each strata <span class="math inline">\(h\)</span>, <span class="math inline">\(C_{hc}\)</span>, <span class="math inline">\(c=1,\ldots,n_h\)</span> clusters are drawn, containing <span class="math inline">\(N_{hc}\)</span> households. Furthermore in each cluster <span class="math inline">\(C_{hc}\)</span> of each strata <span class="math inline">\(h\)</span> simple random sampling is performed to select a set of households <span class="math inline">\(Y_{hcj}\)</span>, <span class="math inline">\(j=1,\ldots,n_{hc}\)</span>.</p>
</div>
<div id="bootstrap-procedure" class="section level3">
<h3>Bootstrap procedure</h3>
<p>In contrast to the naive bootstrap procedure where for a stage, containing <span class="math inline">\(n\)</span> sampling units, the bootstrap replicate is obtained by drawing <span class="math inline">\(n\)</span> sampling units with replacement, for the rescaled bootstrap procedure <span class="math inline">\(n^*=\left\lfloor\frac{n}{2}\right\rfloor\)</span> sampling units are drawn without replacement. Given a value <span class="math inline">\(x\)</span>, <span class="math inline">\(\lfloor x\rfloor\)</span> denotes the largest integer smaller than <span class="math inline">\(x\)</span>, whereas <span class="math inline">\(\lceil x\rceil\)</span> denotes the smallest integer lager then <span class="math inline">\(x\)</span>. <span class="citation">(Chipperfield and Preston 2007)</span> have shown that the choice of either <span class="math inline">\(\left\lfloor\frac{n}{2}\right\rfloor\)</span> or <span class="math inline">\(\left\lceil\frac{n}{2}\right\rceil\)</span> is optimal for bootstrap samples without replacement, although <span class="math inline">\(\left\lfloor\frac{n}{2}\right\rfloor\)</span> has the desirable property that the resulting uncalibrated bootstrap weights will never be negative.</p>
<p>At the first stage the <span class="math inline">\(i\)</span>-th bootstrap replicate, <span class="math inline">\(f^{i,1}_{hc}\)</span>, for each cluster <span class="math inline">\(C_{hc}\)</span>,<span class="math inline">\(c=1,\ldots,n_h\)</span>, belonging to strata <span class="math inline">\(h\)</span>, is defined by</p>
<p><span class="math display">\[
  f^{i,1}_{hc} = 1-\lambda_h+\lambda_h\frac{n_h}{n_h^*}\delta_{hc} \quad\quad \forall c \in \{1,\ldots,n_h\} 
\]</span> with <span class="math display">\[
  n_h^* = \left\lfloor\frac{n_h}{2}\right\rfloor
\]</span> <span class="math display">\[
  \lambda_h = \sqrt{\frac{n_h^*(1-\frac{n_h}{N_h})}{n_h-n_h^*}} \quad ,
\]</span></p>
<p>where <span class="math inline">\(\delta_{hc}=1\)</span> if cluster <span class="math inline">\(c\)</span> is selected in the sub-sample of size <span class="math inline">\(n_h^*\)</span> and 0 otherwise.</p>
<p>The <span class="math inline">\(i\)</span>-th bootstrap replicate at the second stage, <span class="math inline">\(f^{i,2}_{hcj}\)</span>, for each household <span class="math inline">\(Y_{hcj}\)</span>, <span class="math inline">\(j=1,\ldots,n_{hc}\)</span>, belonging to cluster <span class="math inline">\(c\)</span> in strata <span class="math inline">\(h\)</span> is defined by</p>
<p><span class="math display">\[
  f^{i,2}_{hcj} = f^{i,1}_{hc} - \lambda_{hc}\sqrt{\frac{n_h}{n_h^*}}\delta_{hc}\left[\frac{n_{hc}}{n_{hc}^*}\delta_{hcj}-1\right] \quad\quad \forall c \in \{1,\ldots,n_h\}
\]</span> with <span class="math display">\[
  n_{hc}^* = \left\lfloor\frac{n_{hc}}{2}\right\rfloor 
\]</span> <span class="math display">\[
  \lambda_{hc} = \sqrt{\frac{n_{hc}^*N_h(1-\frac{n_{hc}}{N_{hc}})}{n_{hc}-n_{hc}^*}} \quad ,
\]</span></p>
<p>where <span class="math inline">\(\delta_{hcj}=1\)</span> if household <span class="math inline">\(j\)</span> is selected in the sub sample of size <span class="math inline">\(n_{hc}^*\)</span> and 0 otherwise.</p>
</div>
<div id="single-psus" class="section level3">
<h3>Single PSUs</h3>
<p>When dealing with multistage sampling designs the issue of single PSUs, e.g. a single response unit is present at a stage or in a strata, can occur. When applying bootstrapping procedures these single PSUs can lead to a variety of issues. For the methodology proposed in this work we combined single PSUs at each stage with the next smallest strata or cluster, before applying the bootstrap procedure.</p>
</div>
<div id="taking-bootstrap-replicates-forward" class="section level3">
<h3>Taking bootstrap replicates forward</h3>
<p>The bootstrap procedure above is applied on the EU-SILC data for each year <span class="math inline">\(y_t\)</span>, <span class="math inline">\(t=1,\ldots,n_y\)</span> separately. Since EU-SILC is a yearly survey with rotating penal design the <span class="math inline">\(i\)</span>-th bootstrap replicate at the second stage, <span class="math inline">\(f^{i,2}_{hcj}\)</span>, for a household <span class="math inline">\(Y_{hcj}\)</span> is taken forward until the household <span class="math inline">\(Y_{hcj}\)</span> drops out of the sample. That is, for the household <span class="math inline">\(Y_{hcj}\)</span>, which enters EU-SILC at year <span class="math inline">\(y_1\)</span> and drops out at year <span class="math inline">\(y_{\tilde{t}}\)</span>, the bootstrap replicates for the years <span class="math inline">\(y_2,\ldots,y_{\tilde{t}}\)</span> are set to the bootstrap replicate of the year <span class="math inline">\(y_1\)</span>.</p>
</div>
<div id="split-households" class="section level3">
<h3>Split households</h3>
<p>Due to the rotating penal design so called split households can occur. For a household participating in the EU-SILC survey it is possible that one or more residents move to a new so called split household, which is followed up on in the next wave. To take this dynamic into account we extended the procedure of taking forward the bootstrap replicate of a household for consecutive waves of EU-SILC by taking forward the bootstrap replicate to the split household. That means, that also any new individuals in the split household will inherit this bootstrap replicate.</p>
<p>Taking bootstrap replicates forward as well as considering split households ensures that bootstrap replicates are more comparable in structure with the actual design of EU-SILC.</p>
</div>
<div id="uncalibrated-bootstrap-weights" class="section level3">
<h3>Uncalibrated bootstrap weights</h3>
<p>Using the <span class="math inline">\(i\)</span>-th bootstrap replicates at the second stage one can calculate the <span class="math inline">\(i\)</span>-th uncalibrated bootstrap weights <span class="math inline">\(b_{hcj}^{i}\)</span> for each household <span class="math inline">\(Y_{hcj}\)</span> in cluster <span class="math inline">\(c\)</span> contained in strata <span class="math inline">\(h\)</span> by</p>
<p><span class="math display">\[
  \tilde{b}_{hcj}^{i} = f^{i,2}_{hcj} w_{hcj} \quad,
\]</span> where <span class="math inline">\(w_{hcj}\)</span> corresponds to the original household weight contained in the sample.</p>
<p>For ease of readability we will drop the subindices regarding strata <span class="math inline">\(h\)</span> and cluster <span class="math inline">\(c\)</span> for the following sections, meaning that the <span class="math inline">\(j\)</span>-th household in cluster <span class="math inline">\(c\)</span> contained in strata <span class="math inline">\(h\)</span>, <span class="math inline">\(Y_{hcj}\)</span>, will now be denoted as the <span class="math inline">\(j\)</span>-th household, <span class="math inline">\(Y_{j}\)</span>, where <span class="math inline">\(j\)</span> is the position of the household in the data. In accordance to this the <span class="math inline">\(i\)</span>-th uncalibrated bootstrap replicates for household <span class="math inline">\(j\)</span> are thus denoted as <span class="math inline">\(\tilde{b}_j^{i}\)</span> and the original household weight as <span class="math inline">\(w_j\)</span>.</p>
</div>
</div>
<div id="iterative-proportional-fitting-ipf" class="section level2">
<h2>Iterative proportional fitting (IPF)</h2>
<p>The uncalibrated bootstrap weights <span class="math inline">\(\tilde{b}_j^{i}\)</span> computed through the rescaled bootstrap procedure yields population statistics that differ from the known population margins of specified sociodemographic variables for which the base weights <span class="math inline">\(w_j\)</span> have been calibrated. To adjust for this the bootstrap weights <span class="math inline">\(\tilde{b}_{j}^{i}\)</span> can be recalibrated using iterative proportional fitting as described in <span class="citation">(Meraner, Gumprecht, and Kowarik 2016)</span>.</p>
<p>Let the original weight <span class="math inline">\(w_{j}\)</span> be calibrated for <span class="math inline">\(n=n_P+n_H\)</span> sociodemographic variables which are divided into the sets <span class="math inline">\(\mathcal{P}:=\{p_{c}, c=1 \ldots,n_P\}\)</span> and <span class="math inline">\(\mathcal{H}:=\{h_{c}, c=1 \ldots,n_H\}\)</span>. <span class="math inline">\(\mathcal{P}\)</span> and <span class="math inline">\(\mathcal{H}\)</span> correspond to personal, for example gender or age, or household variables, like region or households size, respectively. Each variable in either <span class="math inline">\(\mathcal{P}\)</span> or <span class="math inline">\(\mathcal{H}\)</span> can take on <span class="math inline">\(P_{c}\)</span> or <span class="math inline">\(H_{c}\)</span> values with and <span class="math inline">\(N^{p_c}_v\)</span>, <span class="math inline">\(v=1,\ldots,P_c\)</span>, or <span class="math inline">\(N^{h_c}_v\)</span>, <span class="math inline">\(v=1,\ldots,H_c\)</span>, as the corresponding population margins. Starting with <span class="math inline">\(k=0\)</span> the iterative proportional fitting procedure is applied on each <span class="math inline">\(\tilde{b}_j^{i}\)</span>, <span class="math inline">\(i=1,\ldots, B\)</span> separately. The weights are first updated for personal and afterwards updated for household variables. If constraints regarding the populations margins are not met <span class="math inline">\(k\)</span> is raised by 1 and the procedure starts from the beginning. For the following denote as starting weight <span class="math inline">\(\tilde{b}_j^{[0]}:=\tilde{b}_j^{i}\)</span> for fixed <span class="math inline">\(i\)</span>.</p>
<div id="adjustment-and-trimming-for-mathcalp" class="section level3">
<h3>Adjustment and trimming for <span class="math inline">\(\mathcal{P}\)</span></h3>
<p>The uncalibrated bootstrap weight <span class="math inline">\(\tilde{b}_j^{[(n+1)k+c-1]}\)</span> for the <span class="math inline">\(j\)</span>-th observation is iteratively multiplied by a factor so that the projected distribution of the population matches the respective calibration specification <span class="math inline">\(N_{p_c}\)</span>, <span class="math inline">\(c=1, \ldots,n_P\)</span>. For each <span class="math inline">\(c \in \left\{1, \ldots,n_P\right\}\)</span> the calibrated weights against <span class="math inline">\(N^{p_c}_v\)</span> are computed as <span class="math display">\[
  \tilde{b}_j^{[(n+1)k+c]} = {\tilde{b}_j}^{[(n+1)k+c-1]}\frac{N^{p_c}_v}{{\sum\limits_l} {\tilde{b}}_l^{[(n+1)k+c-1]}},
\]</span> where the summation in the denominator expands over all observations which have the same value as observation <span class="math inline">\(j\)</span> for the sociodemographic variable <span class="math inline">\(p_c\)</span>. If any weights <span class="math inline">\(\tilde{b}_j^{[nk+c]}\)</span> fall outside the range <span class="math inline">\(\left[\frac{w_j}{4};4w_j\right]\)</span> they will be recoded to the nearest of the two boundaries. The choice of the boundaries results from expert-based opinions and restricts the variance of which has a positive effect on the sampling error. This procedure represents a common form of weight trimming where very large or small weights are trimmed in order to reduce variance in exchange for a possible increase in bias (<span class="citation">(Potter 1990)</span>,<span class="citation">(Potter 1993)</span>).</p>
</div>
<div id="averaging-weights-within-households" class="section level3">
<h3>Averaging weights within households</h3>
<p>Since the sociodemographic variables <span class="math inline">\(p_1,\ldots,p_{n_c}\)</span> include person-specific variables, the weights <span class="math inline">\(\tilde{b}_j^{[nk+n_p]}\)</span> resulting from the iterative multiplication can be unequal for members of the same household. This can lead to inconsistencies between results projected with household and person weights. To avoid such inconsistencies each household member is assigned the mean of the household weights. That is for each person <span class="math inline">\(j\)</span> in household <span class="math inline">\(a\)</span> with <span class="math inline">\(h_a\)</span> household members, the weights are defined by <span class="math display">\[
  \tilde{b}_j^{[(n+1)k+n_p+1]} = \frac{{\sum\limits_{l\in a}} {\tilde{b}_l^{[(n+1)k+n_p]}}}{h_a}
\]</span> This can result in losing the population structure performed in the previous subsection.</p>
</div>
<div id="adjustment-and-trimming-for-mathcalh" class="section level3">
<h3>Adjustment and trimming for <span class="math inline">\(\mathcal{H}\)</span></h3>
<p>After adjustment for individual variables the weights <span class="math inline">\(b_j^{[nk+n_p+1]}\)</span> are updated for the set of household variables <span class="math inline">\(\mathcal{H}\)</span> according to a household convergence constraint parameter <span class="math inline">\(\epsilon_h\)</span>. The parameters <span class="math inline">\(\epsilon_h\)</span> represent the allowed deviation from the population margins using the weights <span class="math inline">\(b_j^{[nk+n_p+1]}\)</span> compared to <span class="math inline">\(N^{h_c}_v\)</span>, <span class="math inline">\(c=1,\ldots,n_H\)</span>, <span class="math inline">\(v=1,\ldots,H_c\)</span>. The updated weights are computed as <span class="math display">\[
  b_j^{[(n+1)k+n_p+c+1]} =
  \begin{cases}
    b_j^{[(n+1)k+n_p+1]}\frac{N^{h_c}_v}{\sum\limits_{l} b_l^{[(n+1)k+n_p+1]}} \quad \text{if } \sum\limits_{l} b_j^{[(n+1)k+n_p+1]} \notin ((1-0.9\epsilon_h)N^{h_c}_v,(1+0.9\epsilon_h)N^{h_c}_v) \\
    b_j^{[(n+1)k+n_p+1]} \quad \text{otherwise}
  \end{cases}
\]</span> with the summation in the denominator ranging over all households <span class="math inline">\(l\)</span> which take on the same values for <span class="math inline">\(h_c\)</span> as observation <span class="math inline">\(j\)</span>. As described in the previous subsection the new weight are recoded if they exceed the interval <span class="math inline">\([\frac{w_j}{4};4w_j]\)</span> and set to the upper or lower bound, depending of <span class="math inline">\(b_j^{[(n+1)k+n_p+c+1]}\)</span> falls below or above the interval respectively.</p>
</div>
<div id="convergence" class="section level3">
<h3>Convergence</h3>
<p>For each adjustment and trimming step the factor <span class="math inline">\(\frac{N^{(.)}_v}{\sum\limits_{l} b_l^{[(n+1)k+j]}}\)</span>, <span class="math inline">\(j\in \{1,\ldots,n+1\}\backslash \{n_p+1\}\)</span>, is checked against convergence constraints for households, <span class="math inline">\(\epsilon_h\)</span>, or personal variables <span class="math inline">\(\epsilon_p\)</span>, where <span class="math inline">\((.)\)</span> corresponds to either a household or personal variable. To be more precise for variables in <span class="math inline">\(\mathcal{P}\)</span> the constraints</p>
<p><span class="math display">\[
\frac{N^{p_c}_v}{{\sum\limits_l} {\tilde{b}}_l^{[(n+1)k+j]}} \in ((1-\epsilon_p)N^{p_c}_v,(1+\epsilon_p)N^{p_c}_v)
\]</span> and for variables in <span class="math inline">\(\mathcal{H}\)</span> the constraints</p>
<p><span class="math display">\[
\frac{N^{h_c}_v}{{\sum\limits_l} {\tilde{b}}_l^{[(n+1)k+j]}} \in ((1-\epsilon_h)N^{h_c}_v,(1+\epsilon_h)N^{h_c}_v)
\]</span> are verified, where the sum in the denominator expands over all observations which have the same value for variables <span class="math inline">\(h_c\)</span> or <span class="math inline">\(p_c\)</span>. If these constraints hold true the algorithm reaches convergence, otherwise <span class="math inline">\(k\)</span> is raised by 1 and the procedure repeats itself.</p>
<p>The above described calibration procedure is applied on each year <span class="math inline">\(y_t\)</span> of EU-SILC separately, <span class="math inline">\(t=1,\ldots n_y\)</span>, thus resulting in so called calibrated bootstrap sample weights <span class="math inline">\(b_{j}^{(i,{y_t})}\)</span>, <span class="math inline">\(i=1,\ldots,B\)</span> for each year <span class="math inline">\(y\)</span> and each household <span class="math inline">\(j\)</span>.</p>
</div>
</div>
<div id="variance-estimation" class="section level2">
<h2>Variance estimation</h2>
<p>Applying the previously described algorithms to EU-SILC data for multiple consecutive years <span class="math inline">\(y_t\)</span>, <span class="math inline">\(t=1,\ldots n_y\)</span>, yields calibrated bootstrap sample weights <span class="math inline">\(b_{j}^{(i,{y_t})}\)</span> for each year <span class="math inline">\(y_t\)</span>. Using the calibrated bootstrap sample weights it is straight forward to compute the standard error of a point estimate <span class="math inline">\(\theta(\textbf{X}^{y_t},\textbf{w}^{y_t})\)</span> for year <span class="math inline">\(y_t\)</span> with <span class="math inline">\(\textbf{X}^{y_t}=(X_1^{y_t},\ldots,X_n^{y_t})\)</span> as the vector of observations for the variable of interest in the survey and <span class="math inline">\(\textbf{w}^{y_t}=(w_1^{y_t},\ldots,w_n^{y_t}\)</span> as the corresponding weight vector, with</p>
<p><span class="math display">\[
  sd(\theta) = \sqrt{\frac{1}{B-1}\sum\limits_{i=1}^B (\theta^{(i,y_t)}-\overline{\theta^{(.,y_t)}})^2} 
\]</span> with <span class="math display">\[
  \overline{\theta^{(.,y_t)}} = \frac{1}{B}\sum\limits_{i=1}^B\theta^{(i,y_t)} \quad,
\]</span> where <span class="math inline">\(\theta^{(i,y_t)}:=\theta(\textbf{X}^{y_t},\textbf{b}^{(i,{y_t})})\)</span> is the estimate of <span class="math inline">\(\theta\)</span> in the year <span class="math inline">\(y_t\)</span> using the <span class="math inline">\(i\)</span>-th vector of calibrated bootstrap weights.</p>
<p>As already mentioned the standard error estimation for indicators in EU-SILC yields high quality results for NUTS1 or country level. When estimation indicators on regional or other sub-aggregate levels one is confronted with point estimates yielding high variance.</p>
<p>To overcome this issue we propose to estimate <span class="math inline">\(\theta\)</span> for 3, consecutive years using the calibrated bootstrap weights, thus calculating <span class="math inline">\(\{\theta^{(i,y_{t-1})},\theta^{(i,y_t)},\theta^{(i,y_{t+1})}\}\)</span>, <span class="math inline">\(i=1,\ldots,B\)</span>. For fixed <span class="math inline">\(i\)</span> one can apply a filter with equal filter weights on the time series <span class="math inline">\(\{\theta^{(i,y_{t-1})},\theta^{(i,y_t)},\theta^{(i,y_{t+1})}\}\)</span> to create <span class="math inline">\(\tilde{\theta}^{(i,y_t)}\)</span></p>
<p><span class="math display">\[
  \tilde{\theta}^{(i,y_t)} = \frac{1}{3}\left[\theta^{(i,y_{t-1})}+\theta^{(i,y_t)}+\theta^{(i,y_{t+1})}\right] \quad .
\]</span></p>
<p>Doing this for all <span class="math inline">\(i\)</span>, <span class="math inline">\(i=1,\ldots,B\)</span>, yields <span class="math inline">\(\tilde{\theta}^{(i,y_t)}\)</span>, <span class="math inline">\(i=1,\ldots,B\)</span>. The standard error of <span class="math inline">\(\theta\)</span> can then be estimated with</p>
<p><span class="math display">\[
  sd(\theta) = \sqrt{\frac{1}{B-1}\sum\limits_{i=1}^B (\tilde{\theta}^{(i,y_t)}-\overline{\tilde{\theta}^{(.,y_t)}})^2}
\]</span> with <span class="math display">\[
  \overline{\tilde{\theta}^{(.,y_t)}}=\frac{1}{B}\sum\limits_{i=1}^B\tilde{\theta}^{(i,y_t)} \quad.
\]</span></p>
<p>Applying the filter over the time series of estimated <span class="math inline">\(\theta^{(i,y_t)}\)</span> leads to a reduction of variance for <span class="math inline">\(\theta\)</span> since the filter reduces the noise in <span class="math inline">\(\{\theta^{(i,y_{t-1})},\theta^{(i,y_t)},\theta^{(i,y_{t+1})}\}\)</span> and thus leading to a more narrow distribution for <span class="math inline">\(\tilde{\theta}^{(i,y_t)}\)</span>.</p>
<p>It should also be noted that estimating indicators from a survey with rotating panel design is in general not straight forward because of the high correlation between consecutive years. However with our approach to use bootstrap weights, which are independent from each other, we can bypass the cumbersome calculation of various correlations, and apply them directly to estimate the standard error. <span class="citation">(Bauer et al. 2013)</span> showed that using the proposed method on EU-SILC data for Austria the reduction in resulting standard errors corresponds in a theoretical increase in sample size by about 25<span class="math inline">\(\%\)</span>. Furthermore this study compared this method to the use of small area estimation techniques and on average the use of bootstrap sample weights yielded more stable results.</p>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-silcstudy">
<p>Bauer, Martin, Matthias Till, Richard Heuberger, Marcel Bilgili, Thomas Glaser, Elisabeth Kafka, Johannes Klotz, et al. 2013. “Studie Zu Armut Und Sozialer Eingliederung in Den Bundesländern.” Statistik Austria [in German].</p>
</div>
<div id="ref-chipprest2007">
<p>Chipperfield, James, and John Preston. 2007. “Efficient Bootstrap for Business Surveys.” <em>Survey Methodology</em> 33 (December): 167–72. <a href="https://www.researchgate.net/publication/299052617_Efficient_bootstrap_for_business_surveys">https://www.researchgate.net/publication/299052617_Efficient_bootstrap_for_business_surveys</a>.</p>
</div>
<div id="ref-efron1979">
<p>Efron, B. 1979. “Bootstrap Methods: Another Look at the Jackknife.” <em>Ann. Statist.</em> 7 (1): 1–26. <a href="https://doi.org/10.1214/aos/1176344552">https://doi.org/10.1214/aos/1176344552</a>.</p>
</div>
<div id="ref-mekogu2016">
<p>Meraner, Angelika, Daniela Gumprecht, and Alexander Kowarik. 2016. “Weighting Procedure of the Austrian Microcensus Using Administrative Data.” <em>Austrian Journal of Statistics</em> 45 (June): 3. <a href="https://doi.org/10.17713/ajs.v45i3.120">https://doi.org/10.17713/ajs.v45i3.120</a>.</p>
</div>
<div id="ref-potter90">
<p>Potter, Frank J. 1990. “A Study of Procedures to Identify and Trim Extreme Sampling Weights.” <em>Proceedings of the American Statistical Association, Section on Survey Research Methods</em>, 225–30. <a href="https://www.researchgate.net/publication/242577922_A_study_of_procedures_to_identify_and_trim_extreme_sampling_weights">https://www.researchgate.net/publication/242577922_A_study_of_procedures_to_identify_and_trim_extreme_sampling_weights</a>.</p>
</div>
<div id="ref-potter93">
<p>———. 1993. “The Effect of Weight Trimming on Nonlinear Survey Estimates.” <em>Proceedings of the American Statistical Association, Section on Survey Research Methods</em> 2: 758–63. <a href="https://www.iser.essex.ac.uk/research/publications/498663">https://www.iser.essex.ac.uk/research/publications/498663</a>.</p>
</div>
<div id="ref-prest2009">
<p>Preston, J. 2009. “Rescaled Bootstrap for Stratified Multistage Sampling.” <em>Survey Methodology</em> 35 (December): 227–34. <a href="https://www.researchgate.net/publication/281735659_Rescaled_bootstrap_for_stratified_multistage_sampling">https://www.researchgate.net/publication/281735659_Rescaled_bootstrap_for_stratified_multistage_sampling</a>.</p>
</div>
<div id="ref-raowu1988">
<p>Rao, J. N. K., and C. F. J. Wu. 1988. “Resampling Inference with Complex Survey Data.” <em>Journal of the American Statistical Association</em> 83 (401): 231–41. <a href="https://doi.org/10.2307/2288945">https://doi.org/10.2307/2288945</a>.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
