# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' helping function for bootstrap (compute local means)
#' @keywords internal
mean_help <- function(x, l, r) {
    .Call(`_mosum_mean_help`, x, l, r)
}

#' Compute bootstrapped mosum statistic and return maximum position thereof
#' @keywords internal
get_k_star <- function(x_star, k_hat, G_l, G_r) {
    .Call(`_mosum_get_k_star`, x_star, k_hat, G_l, G_r)
}

#' Obtain bootstrap replicate of time series
#' @keywords internal
bootstrapped_timeSeries <- function(cpts, x) {
    .Call(`_mosum_bootstrapped_timeSeries`, cpts, x)
}

#' Helping function to get bootstrap replicates of change point estimates
#' @keywords internal
cpts_bootstrap_help <- function(cpts_info, x, N_reps) {
    .Call(`_mosum_cpts_bootstrap_help`, cpts_info, x, N_reps)
}

#' Get integer vector of changepoint indices,
#' based on bool-field representation of combinations.
#' E.g. for combination index 11 [=1011]: get_comb_ind(c(T,F,T,T))=11
#' @keywords internal
get_comb_ind <- function(active) {
    .Call(`_mosum_get_comb_ind`, active)
}

#' Helping function for algorithm 2: Pre-compute the partial sums
#' S_i = sum{j=k_i+1}^{k_{i+1}}x_i and the partial sums of squared
#' T_i = sum{j=k_i+1}^{k_{i+1}}x_i^2
#' between the (sorted) candidates k_i and k_{i+1} in cand.
#' Output: data frame with 4 columns k_i | k_{i+1} | S_i | T_i
#' @keywords internal
extract_sub <- function(cand, x) {
    .Call(`_mosum_extract_sub`, cand, x)
}

#' Starting value to iterate (in lexicographical order) 
#' over all bit permutaions having l bits set to 1.
#' E.g.: start_bit_permutations(2) = 3 [=0..011].
#' @keywords internal
start_bit_permutations <- function(l) {
    .Call(`_mosum_start_bit_permutations`, l)
}

#' Next value to iterate (in lexicographical order) over all bit 
#' permutaions having l bits set to 1.
#' Example sequence (2 bits): {0011, 0101, 0110, 1001, 1010, 1100}.
#' Source: https://stackoverflow.com/questions/1851134/generate-all-binary-strings-of-length-n-with-k-bits-set
#' @keywords internal
next_bit_permutation <- function(v) {
    .Call(`_mosum_next_bit_permutation`, v)
}

#' Is index i_child a child of index i_parent?
#' ASSERT: i_child is of the form (i_parent XOR i_help),
#'         with i_help having exactly one non-zero bit
#' @keywords internal
is_child <- function(i_child, i_parent) {
    .Call(`_mosum_is_child`, i_child, i_parent)
}

#' Get number of non-zero bits of a 32bit integer
#' Source: https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer
#' @keywords internal
numberOfSetBits <- function(i) {
    .Call(`_mosum_numberOfSetBits`, i)
}

#' Does the combination comb of changepoints contain the changepoint k_ind?
#' @keywords internal
comb_contains_cpt <- function(comb, k_ind) {
    .Call(`_mosum_comb_contains_cpt`, comb, k_ind)
}

#' Compute the Local cost terms of combination icomb (for RSS resp. sBIC).
#' Use pre-computed partial sum matrix sub_sums (see extract_sub) for speedup
#' @keywords internal
get_local_costs <- function(icomb, sub_sums) {
    .Call(`_mosum_get_local_costs`, icomb, sub_sums)
}

#' where is leftmost one?
#' https://www.geeksforgeeks.org/find-significant-set-bit-number/
#' @keywords internal
setBitNumber <- function(n) {
    .Call(`_mosum_setBitNumber`, n)
}

#' Algorithm II (Local change-point search with SC)
#' 
#' Input cand: =mathcal D, conflicting changepoints candidate set
#' Input sub_sums: Pre-computed partial sums, as obtained by extract_sub
#' Input strength: Exponent for penalty
#' Input log_penalty: log (or polynomial) penalty term?
#' Input n: Overall length of data
#' Input auc: =|mathcal C|, total number of currently active changepoints 
#'       (+candidates)
#' Input min_cost: Minimal RSS with all the candidates
#' 
#' Output sc: (Mx2) matrix (M=2^m with m=|cand|) containing RSS/cost and SC
#'         terms for all combinations within cand. Combinations are indexed
#'         by their implicit integer representation, i.e. sc[0,] corresponds
#'         to the empty set, sc[3,] to {k_1,k_2} [0..011], etc.
#'         Note: Row May be Inf, if combination was not visited in algorithm.
#' Output est_cpts: Integer Vector of estimated changepoints
#' Output final: Bool Vector indicating if combinations are final states
#' Output num_cpts: For debugging purposes
#' @keywords internal
exhaust_sc <- function(cand, sub_sums, strength, log_penalty, n, auc, min_cost) {
    .Call(`_mosum_exhaust_sc`, cand, sub_sums, strength, log_penalty, n, auc, min_cost)
}

#' equivalent to rollsum(x, k=G, fill=NA, align="left") in the package zoo, 
#' but optimized for speed
#' @keywords internal
rolling_sum <- function(x, G) {
    .Call(`_mosum_rolling_sum`, x, G)
}

#' extract changepoints from candidates with eta criterion
#' @keywords internal
eta_criterion_help <- function(candidates, m_values, eta, G_left, G_right) {
    .Call(`_mosum_eta_criterion_help`, candidates, m_values, eta, G_left, G_right)
}

