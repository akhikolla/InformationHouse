% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggR.R
\name{ggR}
\alias{ggR}
\title{Plot RasterLayers in ggplot with greyscale}
\usage{
ggR(img, layer = 1, maxpixels = 5e+05, alpha = 1, hue = 1,
  sat = 0, stretch = "none", quantiles = c(0.02, 0.98),
  coord_equal = TRUE, ggLayer = FALSE, ggObj = TRUE,
  geom_raster = FALSE, forceCat = FALSE)
}
\arguments{
\item{img}{raster}

\item{layer}{Character or numeric. Layername or number. Can be more than one layer, in which case each layer is plotted in a subplot.}

\item{maxpixels}{Integer. Maximal number of pixels to sample.}

\item{alpha}{Numeric. Transparency (0-1).}

\item{hue}{Numeric. Hue value for color calculation [0,1] (see \[grDevices]{hsv}). Change if you need anything else than greyscale. Only effective if \code{sat > 0}.}

\item{sat}{Numeric. Saturation value for color calculation [0,1] (see \[grDevices]{hsv}). Change if you need anything else than greyscale.}

\item{stretch}{Character. Either 'none', 'lin', 'hist', 'sqrt' or 'log' for no stretch, linear, histogram, square-root or logarithmic stretch.}

\item{quantiles}{Numeric vector with two elements. Min and max quantiles to stretch to. Defaults to 2\% stretch, i.e. c(0.02,0.98).}

\item{coord_equal}{Logical. Force addition of coord_equal, i.e. aspect ratio of 1:1. Typically useful for remote sensing data (depending on your projection), hence it defaults to TRUE.
Note however, that this does not apply if (\code{ggLayer=FALSE}).}

\item{ggLayer}{Logical. Return only a ggplot layer which must be added to an existing ggplot. If \code{FALSE} s stand-alone ggplot will be returned.}

\item{ggObj}{Logical. Return a stand-alone ggplot object (TRUE) or just the data.frame with values and colors}

\item{geom_raster}{Logical. If \code{FALSE} uses annotation_raster (good to keep aestetic mappings free). If \code{TRUE} uses \code{geom_raster} (and \code{aes(fill)}). See Details.}

\item{forceCat}{Logical. If \code{TRUE} the raster values will be forced to be categorical (will be converted to factor if needed).}
}
\value{
\tabular{ll}{
 \code{ggObj = TRUE}:   \tab ggplot2 plot \cr
 \code{ggLayer = TRUE}: \tab ggplot2 layer to be combined with an existing ggplot2 \cr
 \code{ggObj = FALSE}:  \tab data.frame in long format suitable for plotting with ggplot2, 
                         includes the pixel values and the calculated colors  \cr  
}
}
\description{
Plot single layer imagery in grey-scale. Can be used with any Raster* object.
}
\details{
When \code{img} contains factor values and \code{annotation=TRUE}, the raster values will automatically be converted
to numeric in order to proceed with the brightness calculation. Ã¤

The raster package provides a class lookup-table for categorical rasters (e.g. what you get if you run superClass in classification mode). If your raster has a lookup-table ggR will automatically treat it as categorical (see \link[raster]{factor}). 
However, the factor status of Raster objects is easily lost and the values are interpreted as numeric. In such cases you should make use of the \code{forceCat = TRUE} argument, which makes sure
that ggplot2 uses a discrete scale, not a continuous one.

The geom_raster argument switches from the default use of annotation_raster to geom_raster. The difference between the two is that geom_raster performs
a meaningful mapping from pixel values to fill colour, while annotation_raster is simply adding a picture to your plot. In practice this means that whenever you 
need a legend for your raster you should use \code{geom_raster = TRUE}. This also allows you to specify and modify the fill scale manually. 
The advantage of using annotation_raster (\code{geom_raster = TRUE}) is that you can still use the scale_fill* for another variable. For example you could add polygons and 
map a value to their fill colour. For more details on the theory behind aestetic mapping have a look at the \href{https://CRAN.R-project.org/package=ggplot2/ggplot2.pdf}{ggplot2} manuals.
}
\examples{
library(ggplot2)
library(raster)
data(rlogo); data(lsat); data(srtm)

## Simple grey scale annotation
ggR(rlogo)

## With linear stretch contrast enhancement
ggR(rlogo, stretch = "lin", quantiles = c(0.1,0.9))

## ggplot with geom_raster instead of annotation_raster
## and default scale_fill*
ggR(rlogo, geom_raster = TRUE)

## with different scale
ggR(rlogo, geom_raster = TRUE) +
        scale_fill_gradientn(name = "mojo", colours = rainbow(10)) +
        ggtitle("**Funkadelic**")

## Plot multiple layers
\donttest{
ggR(lsat, 1:6, geom_raster=TRUE, stretch = "lin") +
    scale_fill_gradientn(colors=grey.colors(100), guide = FALSE) +
    theme(axis.text = element_text(size=5), 
          axis.text.y = element_text(angle=90),
          axis.title=element_blank())

## Don't plot, just return a data.frame
df <- ggR(rlogo, ggObj = FALSE)
head(df, n = 3)

## Layermode (ggLayer=TRUE)
data <- data.frame(x = c(0, 0:100,100), y = c(0,sin(seq(0,2*pi,pi/50))*10+20, 0))
ggplot(data, aes(x, y)) +  ggR(rlogo, geom_raster= FALSE, ggLayer = TRUE) +
       geom_polygon(aes(x, y), fill = "blue", alpha = 0.4) +
       coord_equal(ylim=c(0,75))

## Categorical data 
## In this case you probably want to use geom_raster=TRUE 
## in order to perform aestetic mapping (i.e. a meaningful legend)
rc   <- raster(rlogo)
rc[] <- cut(rlogo[[1]][], seq(0,300, 50))
ggR(rc, geom_raster = TRUE)

## Legend cusomization etc. ...
ggR(rc, geom_raster = TRUE) + scale_fill_discrete(labels=paste("Class", 1:6))
}
## Creating a nicely looking DEM with hillshade background
terr <- terrain(srtm, c("slope", "aspect"))
hill <- hillShade(terr[["slope"]], terr[["aspect"]])
ggR(hill)

ggR(hill) + 
   ggR(srtm, geom_raster = TRUE, ggLayer = TRUE, alpha = 0.3) +
   scale_fill_gradientn(colours = terrain.colors(100), name = "elevation")
}
\seealso{
\link{ggRGB}, \link[=fortify.raster]{fortify}
}
