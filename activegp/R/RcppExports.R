# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Computes Int(kappa_i(X, design) . kappa_j(design, X)). This function is preferred for initialization
#' @title Covariance of kernel computations
#' @param design matrix of design points
#' @param theta lengthscales
#' @param Ki The inverse covariance matrix
#' @param Kir The inverse covariance matrix times the response.
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return The matrix representing the result of the integration.
#' @export
#' @keywords internal
C_GP_cpp <- function(design, response, theta, Ki, ct) {
    .Call('_activegp_C_GP_cpp', PACKAGE = 'activegp', design, response, theta, Ki, ct)
}

d_gauss_cpp <- function(X, x, sigma) {
    .Call('_activegp_d_gauss_cpp', PACKAGE = 'activegp', X, x, sigma)
}

d_mat52_cpp <- function(X, x, sigma) {
    .Call('_activegp_d_mat52_cpp', PACKAGE = 'activegp', X, x, sigma)
}

d_mat32_cpp <- function(X, x, sigma) {
    .Call('_activegp_d_mat32_cpp', PACKAGE = 'activegp', X, x, sigma)
}

#' int_0_1 k(x, x') dx
#' @param a design location
#' @param t lengthscale parameter
#' @noRd
NULL

#' int_0_1 dk(x,x')/dx dx
#' @param a design location
#' @param t lengthscale parameter
#' @noRd
NULL

#' int_0_1( d_k(x,a)/dx * d_k(b,x) dx) (univariate)
#' @param a,b design locations
#' @param t lengthscale parameter
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return The scalar integrated derivative as a double.
#' @noRd
w_ii_cpp <- function(a, b, t, ct) {
    .Call('_activegp_w_ii_cpp', PACKAGE = 'activegp', a, b, t, ct)
}

#' Gradient of int_0_1( d_k(x,a)/dx * d_k(b,x) dx) (univariate) with respect to a.
#' @param a,b design locations
#' @param t lengthscale parameter
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return The scalar integrated derivative as a double.
#' @noRd
grad_w_ii_cppa <- function(a, b, t, ct) {
    .Call('_activegp_grad_w_ii_cppa', PACKAGE = 'activegp', a, b, t, ct)
}

#' Gradient of int_0_1( d_k(x,a)/dx * d_k(b,x) dx) (univariate) with respect to b.
#' @param a,b design locations
#' @param t lengthscale parameter
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return The scalar integrated derivative as a double. 
#' @noRd
grad_w_ii_cppb <- function(a, b, t, ct) {
    .Call('_activegp_grad_w_ii_cppb', PACKAGE = 'activegp', a, b, t, ct)
}

#' int_0_1( d_k(x, a)/dx_i k(b, x) dx) (univariate)
#' @param a,b design locations
#' @param t lengthscale parameter
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return The scalar integrated derivative as a double.
#' @noRd
w_ij_cpp <- function(a, b, t, ct) {
    .Call('_activegp_w_ij_cpp', PACKAGE = 'activegp', a, b, t, ct)
}

#' int_0_1( d_k(x, a)/dx_i k(b, x) dx) (univariate)
#' @param a,b design locations
#' @param t lengthscale parameter
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return The scalar integrated derivative as a double.
#' @noRd
grad_w_ij_cppa <- function(a, b, t, ct) {
    .Call('_activegp_grad_w_ij_cppa', PACKAGE = 'activegp', a, b, t, ct)
}

#' int_0_1( d_k(x, a)/dx_i k(b, x) dx) (univariate)
#' @param a,b design locations
#' @param t lengthscale parameter
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return The scalar integrated derivative as a double.
#' @noRd
grad_w_ij_cppb <- function(a, b, t, ct) {
    .Call('_activegp_grad_w_ij_cppb', PACKAGE = 'activegp', a, b, t, ct)
}

#' int_0_1 k(x, a) * k(b, x) dx
#' @noRd
Ikk_cpp <- function(a, b, t, ct) {
    .Call('_activegp_Ikk_cpp', PACKAGE = 'activegp', a, b, t, ct)
}

#' Derivative of int_0_1 k(x, a) * k(b, x) dx With respect to a.
#' @noRd
grad_Ikk_cppa <- function(a, b, t, ct) {
    .Call('_activegp_grad_Ikk_cppa', PACKAGE = 'activegp', a, b, t, ct)
}

#' Derivative of int_0_1 k(x, a) * k(b, x) dx With respect to b.
#' @noRd
grad_Ikk_cppb <- function(a, b, t, ct) {
    .Call('_activegp_grad_Ikk_cppb', PACKAGE = 'activegp', a, b, t, ct)
}

#' Computes Int(kappa_i(X, design) . kappa_j(design, X)). This function is preferred for initialization
#' @title Covariance of kernel computations
#' @param design matrix of design points
#' @param theta lengthscales
#' @param i1,i2 index of the derivatives (WARNING: starts at 0)
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return The matrix representing the result of the integration.
#' @export
#' @keywords internal
W_kappa_ij <- function(design, theta, i1, i2, ct) {
    .Call('_activegp_W_kappa_ij', PACKAGE = 'activegp', design, theta, i1, i2, ct)
}

#' Computes Int(kappa_i(X, design1) . kappa_j(design2, X)). This function is preferred for initialization
#' @title Covariance of kernel computations 
#' @param design1,design2 matrices of design points
#' @param theta lengthscales
#' @param i1,i2 index of the derivatives (WARNING: starts at 0)
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return matrix of size nrow(design1) x nrow(design2)
#' @keywords internal
W_kappa_ij2 <- function(design1, design2, theta, i1, i2, ct) {
    .Call('_activegp_W_kappa_ij2', PACKAGE = 'activegp', design1, design2, theta, i1, i2, ct)
}

#' Computes gradient of Int(kappa_i(X, design1) . kappa_j(design2, X)) with respect to the first argument.
#' @title Covariance of kernel computations 
#' @param design1 A vector representing a new point.
#' @param design2 matrices of design points
#' @param theta lengthscales
#' @param i1,i2 index of the derivatives (WARNING: starts at 0)
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return matrix of size nrow(design1) x nrow(design2)
#' @keywords internal
grad_W_kappa_ij2 <- function(design1, design2, theta, i1, i2, ct) {
    .Call('_activegp_grad_W_kappa_ij2', PACKAGE = 'activegp', design1, design2, theta, i1, i2, ct)
}

#' Computes gradient of Int(kappa_i(X, design1) . kappa_j(design2, X)) with respect to the second argument.
#' @title Covariance of kernel computations 
#' @param design1 A vector representing a new point.
#' @param design2 matrices of design points
#' @param theta lengthscales
#' @param i1,i2 index of the derivatives (WARNING: starts at 0)
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return matrix of size nrow(design1) x nrow(design2)
#' @keywords internal
grad_W_kappa_ij2_w2 <- function(design1, design2, theta, i1, i2, ct) {
    .Call('_activegp_grad_W_kappa_ij2_w2', PACKAGE = 'activegp', design1, design2, theta, i1, i2, ct)
}

#' Computes Int(kappa_i(X, design) . kappa_j(design, X)). This function is preferred for updates
#' @title Covariance of kernel computations
#' @param W The matrix to store the computation in
#' @param design matrix of design points
#' @param theta lengthscales
#' @param i1,i2 index of the derivatives (WARNING: starts at 0)
#' @param start The column/row index at which to start the computation (doesn't touch the start by start submatrix).
#' @param ct Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2
#' @return W is modified in-place.
#' @keywords internal
#' @export
W_kappa_ij_up <- function(W, design, theta, i1, i2, start, ct) {
    invisible(.Call('_activegp_W_kappa_ij_up', PACKAGE = 'activegp', W, design, theta, i1, i2, start, ct))
}

